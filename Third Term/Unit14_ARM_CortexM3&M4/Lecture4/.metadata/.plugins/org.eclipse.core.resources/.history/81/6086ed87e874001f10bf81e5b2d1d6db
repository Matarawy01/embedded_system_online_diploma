/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
/*
 *  Created on: Nov 16, 2024
 *      Author:  AbdelRahman Matarawy
 */
#include "STM32F103C6_EXTI_Driver.h"

uint8_t IRQ_Flag, TaskA_Flag, TaskB_Flag;
extern int _estack;

#define OS_Set_PSP(address)     		__asm volatile("MOV R0, %0 \n\t MSR PSP, R0" : : "r" (address))

#define OS_Switch_SP_TO_PSP				__asm volatile("MRS R0, CONTROL \n\t MOV R1, #0x02 \n\t orr R0, R0, R1 \n\t MSR CONTROL, R0")
#define OS_Switch_SP_TO_MSP				__asm volatile("MRS R0, CONTROL \n\t MOV R1, #0x05 \n\t and R0, R0, R1 \n\t MSR CONTROL, R0")

#define OS_Generate_Exceptional			__asm volatile("SVC 0x03")

/* Define Stack Size of each Task */
#define TaskA_Stack_Size 				100 // 100 Bytes
#define TaskB_Stack_Size 				100 // 100 Bytes




/* Define Boundaries of MSP and PSP of Tasks */
//MSP Boundaries
uint8_t _S_MSP = & _estack;
uint8_t _E_MSP;

//PSP of Task A
uint8_t _S_PSP_Task_A;
uint8_t _E_PSP_Task_A;

//PSP of Task B
uint8_t _S_PSP_Task_B;
uint8_t _E_PSP_Task_B;

/* Switch Between Privileged and Unprivileged */
enum CPU_AccessLevel{
	privileged,
	unprivileged
};

void Switch_CPU_AccessLevel(enum CPU_AccessLevel LEVEL)
{
	switch(LEVEL)
	{
	case privileged:
		/* Clear Bit 0 in CONTROL register */
		__asm("MRS R3, CONTROL \n\t LSR R3, R3, #0x01 \n\t LSL R3, R3, #0x01 \n\t MSR CONTROL, R3");
		break;
	case unprivileged:
		/* Set Bit 0 in CONTROL register */
		__asm("MRS R3, CONTROL \n\t orr R3, R3, #0x01 \n\t MSR CONTROL, R3");
		break;
	}
}

//clk configuration
void clk_init()
{
	RCC_GPIOB_CLK_EN();
	RCC_AFIO_CLK_EN();
}

void EXTI_CallBack(void)
{
	if(IRQ_Flag == 0)
	{
		TaskA_Flag = 1;
		IRQ_Flag = 1;
	}
	else if(IRQ_Flag == 1)
	{
		TaskB_Flag = 1;
		IRQ_Flag = 0;
	}
}

int TASKA(int a, int b, int c)
{
	return a+b+c;
}

int TASKB(int a, int b, int c, int d)
{
	return a+b+c+d;
}

Start_Os()
{
	/* Set Boundaries of each Stack */
	//MSP
	uint8_t _E_MSP = (_S_MSP - 512);

	//PSP of Task A
	uint8_t _S_PSP_Task_A = (_E_MSP - 8);
	uint8_t _E_PSP_Task_A = (_S_PSP_Task_A - TaskA_Stack_Size);

	//PSP of Task B
	uint8_t _S_PSP_Task_B = (_E_PSP_Task_A - 8);
	uint8_t _E_PSP_Task_B = (_S_PSP_Task_B - TaskB_Stack_Size);

	while(1)
	{
		__asm("NOP");
		if(TaskA_Flag == 1)
		{
			// Set PSP Register -> _S_PSP_Task_A
			OS_Set_PSP(_S_PSP_Task_A);
			// Switch SP to be PSP
			OS_Switch_SP_TO_PSP;
			// Switch to Privileged to unprivileged
			Switch_CPU_AccessLevel(unprivileged);

			TaskA_Flag = TASKA(1, 2, 3);

			// Switch to unprivileged to privileged
			OS_Generate_Exceptional;
			// Switch SP to be MSP
			OS_Switch_SP_TO_MSP;
		}
		else if(TaskB_Flag == 1)
		{
			// Set PSP Register -> _S_PSP_Task_B
			OS_Set_PSP(_S_PSP_Task_B);
			// Switch SP to be PSP
			OS_Switch_SP_TO_PSP;
			// Switch to Privileged to unprivileged
			Switch_CPU_AccessLevel(unprivileged);
			TaskB_Flag = TASKB(1, 2, 3, 4);

			// Switch to unprivileged to privileged
			OS_Generate_Exceptional;
			// Switch SP to be MSP
			OS_Switch_SP_TO_MSP;
		}
	}
}
int main(void)
{
	clk_init();

	/* Set Configuration of EXTI */
	EXTI_Config_t EXTI_Conf;  // Make Variable of EXTI_PinConfig_t structure
	EXTI_Conf.EXTI_PIN = EXTI_LINE9_PB9; // Set line 9, GPIOB, Pin9 an EXTI
	EXTI_Conf.Trigger_Case = EXTI_Trigger_RASING; // Specifies Rising Trigger
	EXTI_Conf.IRQ_Case =EXTI_IRQ_Enable; // Enable Interrupt Mask
	EXTI_Conf.P_IRQ_CallBack = EXTI_CallBack; // Make Call Back Function point to ISR

	MCAL_EXTI_GPIO_Init(&EXTI_Conf);
	IRQ_Flag = 1;

	Start_Os();

	/* When Try to test our function first make it unprivileged
	 *  since main work as thread mode which is PAL */
	Switch_CPU_AccessLevel(unprivileged);
	//Switch_CPU_AccessLevel(privileged);
	while(1)
	{
		if(IRQ_Flag == 1)
		{
			IRQ_Flag = 0;
		}

	}
}
